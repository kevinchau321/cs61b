Name: Kevin Chau
Login: cs61b-mv

Using publically declared methods in the DList class only, a program outside the package can still corrupt a DList invariant, despite package protection of the head and size fields, as well as package protection of the DListNode constructors and fields (next and prev). Here's how: Since the DList constructor is public, a program outside the package can make a reference variable named X of type DList and assign it to a new DList object. Then that program can use the insertFront(Object item) method, which is also public, to create a node in the DList with any object it wants. The application can then call X.remove(X.prev(X.front()))
These are all legal nested calls because X.front() returns the node we first inserted, and X.prev gives us the head of the DList because that is the prev of the front node. Notice that front() and prev() return nodes, which is why we can nest them inside the remove call. Hence we have created a pointer to the head to remove without making any illegal out of package code such as X.head.
The remove method called on the head node will set the head's preve and next field to null (and will also link the first node we inserted to itself).
Of course, this depends on a critical weakness in the remove(node) method. If remove only stops when node == null, then it will have no problem removing the head node. This violates the first DList invariant, which is that head prev and next field cannot be null. Technically, the head is still in the list though, but only the package classes can axcess it.
An else if (this.isEmpty()) {..} clause in the remove() method can prevent this invariant from breaking, but there are also other ways that an out of package application could illegally axcess protected fields, such as overriding methods or making subclasses that inherit control of these protected fields. 